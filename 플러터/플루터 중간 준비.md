# 0장
## 앱 개발 방식
네이티브 방식
안드로이드나 ios 같은 플랫폼 자체에서 제공하는 개발환경으로 개발
자바, ㅓ코틀린
혼자 개발하기 쉽지 않음

하이브리드 방식
웹 기술로 앱 화면을 만든 후 네이티브 기술로 감싸서 앱 형태로 포장
네이티브 성능에 미치지 못함
UI 또한 별도로 만듦

크로스 플랫폼 방식
한 번 구현하여 안드로이드와 ios 등 각 플랫폼용 앱을 만든다
빌드할 때 네이티브 코드로 변환 -> 네이티브 방식과 같은 성능
가장 선호하는 방식

==
## 플러터 특징
한 번 코딩으로 여러 플랫폼용 앱을 만드는 크로스 플랫폼 개발 프레임워크

낮은 진입장벽
높은 네이티브 성능
훌륭한 개발 도구 지원
예쁜 UI

==
# 1장
## 환경 구성 검사

첫 번째 방법
터미널에서 플러터 명령을 실행

두 번째 방법
안드로이드 스튜디오 하단에 있는 'Terminal' 탭을 눌러서 터미널을 실행하고 flutter doctor 명령을 직접 입력하는 법

위 두 방법은 윈도우에 환경변수를 등록해야 함
flutter doctor 명령을 실행하면 라이선스와 기기 관련해서 문제가 있다고 표시 됌

세 번째 방법
프로젝트 창에서 'flutter_app > test > pubspec.yaml' 을 선택하고,
오른쪽 상단 4가지 링크 중 'flutter doctor'를 클릭하는 법

출력 결과는 'Flutter' 창에서 확인할 수 있습니다

세 번째 방법은 SDK를 환경 변수에 추가하지 않아도 작동하므로 편리
flutter doctor --verbose 옵션이 붙은 명령이 수행되어 좀 더 자세한 결과를 보여줌

오른쪽 상단 4가지 링크의 역할
Pub get : 외부 라이브러리를 추가한 후 프로젝트에 다운로드하여 적용함
Pub upgrade : 지정된 버전 중 가장 최신 버전을 검색

==
# 2장
## 다트의 변수 타입

int : 정수
double : 실수(소수점)
String : 문자열
bool : 참 또는 거짓 값을 갖는 타입(불리언 타입이라고 읽음)

## 상수 final과 const
변수는 값이 변경되어 의도치 않게 에러를 발생할 가능성이 있으므로 가급적이면 값이 변하지않게 상수로 하는게 좋음

## 타입 변환, 형 변환
is : 같은 타입이면 true
is! : 다른 타입이면 true

## 형 변환
다른 타입끼리는 변환이 안 되고 더 상위 개념으로 변환 가능

int와 double은 모두 num을 구현하는 타입이지만 서로 관계가 없기 때문에 형변환 불가
var c = 30.5;
int d = c as int; //에러

int와 double 모두 상위 개념인 num으로 형변환 가능
※ dynamic 모든 데이터 타입 허용
dynamic d = 30.5;
num n = d;

## 익명 함수 
이름 없는 익명 함수(무명 함수)도 정의해 사용 가능
([인수명]) {[동작 또는 반환값]}
다음 익명 함수는 number가 짝수면 ture를 홀수면 false를 반환
(number){
   return number % 2 == 0;
};

## 람다식
람다 표현식(이하 람다식)이라는 함수 표현 방식을 지원합니다
=> 왼쪽에는 인수명을 작성하고 오른쪽에는 동작할 코드 또는 반환값을 작성
([인수명]) => [동작 또는 반환값]
(number) => number%2 == 0;

## 클래스 정의
컴퓨터 세계에서 객체는 저장 공간에 할당되어 값을 가지거나 식별자에 의해 참조되는 공간
변수, 자료 구조, 함수 또는 메서드 등이 객체가 될 수 있음
이러한 객체를 메모리에 작성하는 것을 인스턴스화한다고 함
메모리에 작성된 객체를 인스턴스라고 함

이해하기 위한 주석 (인스턴스화는 클래스를 가지고 찍어낸 결과물)
인스턴스화를 위해서는 설계도가 필요한데 설계도 역할이 클래스이다
클래스 안에 속성을 표현할 수 있는데 이를 프로퍼티라고 한다

이름과 나이 프로퍼티를 가진 사람을 정의한 클래스
class Person{
   String name;
   int age;

   void addOneYear() {
     age++;
   }

var person = Person();
person.age =10;
person.addOneYear();
print(person.age);
}

## 상속








































